<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SF â†’ NYC Road Trip (Car View + Live Weather)</title>
  <!--
    IMPORTANT ABOUT BAKING IN YOUR GOOGLE API KEY

    If you put your key directly in this file and host it on GitHub Pages,
    your key is PUBLIC (anyone can view-source and copy it).

    If you still want it baked in (plug-and-play), do BOTH:
      1) Restrict the key to your site (HTTP referrers):
         https://YOUR_GITHUB_USER.github.io/*
      2) Restrict the key to ONLY the needed APIs (at minimum: Maps JavaScript API).

    Also: you pasted a key in chat earlier â€” assume it is compromised.
    Rotate the key in Google Cloud, then paste the NEW key below.
  -->
  <style>
    html,body{height:100%;margin:0;background:#05070b;color:#e8eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
    #wrap{position:fixed;inset:0}

    /* z-order layering */
    #pano{position:absolute;inset:0;z-index:0}
    #windshieldMask{position:absolute;inset:0;z-index:1;pointer-events:none}
    #weatherCanvas{position:absolute;inset:0;z-index:2;pointer-events:none}
    #interior{position:absolute;inset:0;z-index:3;pointer-events:none}

    #hud{position:absolute;left:16px;top:16px;z-index:4;max-width:min(520px,92vw);
      background:rgba(10,16,24,.62);backdrop-filter:blur(10px);
      border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:10px 12px}
    #hud .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    #hud b{color:#fff}
    #hud p{margin:6px 0 0;font-size:12px;opacity:.9;line-height:1.25}

    #panel{position:absolute;left:16px;bottom:16px;z-index:4;width:min(560px,92vw);
      background:rgba(10,16,24,.62);backdrop-filter:blur(10px);
      border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:12px;pointer-events:auto}
    #panel h2{margin:0 0 8px;font-size:14px}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input[type="text"],input[type="password"]{flex:1;min-width:220px;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);color:#e8eef7;outline:none}
    button{padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.14);
      background:rgba(125,211,252,.14);color:#e8eef7;cursor:pointer}
    button:hover{background:rgba(125,211,252,.22)}
    .pill{font-size:12px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.12)}
    label{font-size:12px;opacity:.9}
    #log{margin-top:10px;max-height:170px;overflow:auto;border-radius:12px;background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);padding:8px}
    #log .item{font-size:12px;line-height:1.25;padding:6px 6px;border-bottom:1px solid rgba(255,255,255,.06)}
    #log .item:last-child{border-bottom:none}

    /* Soft vignette mask: emulate side windows */
    .vignette{position:absolute;inset:0;
      background:radial-gradient(1400px 800px at 50% 35%, rgba(0,0,0,0) 0%, rgba(0,0,0,.35) 55%, rgba(0,0,0,.70) 100%);
    }

    /* Non-blocking overlay for messages (click to dismiss) */
    #overlay{position:absolute;inset:0;z-index:10;background:rgba(0,0,0,.75);color:#fff;display:flex;
      align-items:center;justify-content:center;text-align:center;padding:20px;font-size:16px;line-height:1.4;cursor:pointer}
    #overlay.hidden{display:none}
  </style>
</head>
<body>
<div id="wrap">
  <div id="pano"></div>

  <div id="windshieldMask" class="vignette"></div>
  <canvas id="weatherCanvas"></canvas>

  <!-- Simple car interior overlay -->
  <svg id="interior" viewBox="0 0 1000 600" preserveAspectRatio="none" aria-hidden="true">
    <path d="M0,0 L180,0 L300,200 L300,600 L0,600 Z" fill="rgba(0,0,0,0.45)"/>
    <path d="M1000,0 L820,0 L700,200 L700,600 L1000,600 Z" fill="rgba(0,0,0,0.45)"/>
    <path d="M0,450 C220,380 780,380 1000,450 L1000,600 L0,600 Z" fill="rgba(0,0,0,0.65)"/>
    <circle cx="500" cy="520" r="110" fill="none" stroke="rgba(255,255,255,0.12)" stroke-width="18"/>
    <circle cx="500" cy="520" r="72" fill="none" stroke="rgba(255,255,255,0.10)" stroke-width="10"/>
  </svg>

  <div id="hud">
    <div class="row">
      <div class="pill"><b>Speed</b>: 50&nbsp;mph</div>
      <div class="pill"><b>Progress</b>: <span id="progressPct">0.0%</span></div>
      <div class="pill"><b>Miles</b>: <span id="miles">0</span></div>
    </div>
    <p id="status">Loadingâ€¦</p>
    <p style="margin:6px 0 0;font-size:12px;opacity:.9">Weather: <span id="wx">â€”</span></p>
  </div>

  <div id="panel">
    <h2>Controls</h2>
    <div class="controls">
      <!-- Keep the input (handy for quick key swaps), but we auto-fill it from BAKED_API_KEY -->
      <input id="apiKey" type="password" placeholder="Google Maps API key" autocomplete="off"/>
      <button id="startBtn">Start</button>
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>
      <span class="pill"><label><input id="offlineToggle" type="checkbox" style="vertical-align:middle;margin-right:6px">Continue while away</label></span>
    </div>
    <div class="controls" style="margin-top:10px">
      <span class="pill"><b>Now:</b> <span id="nowLoc">San Francisco, CA</span></span>
      <span class="pill"><b>Next:</b> <span id="nextLoc">Oakland, CA</span></span>
    </div>
    <div id="log"></div>
  </div>

  <div id="overlay" class="hidden">Click to dismiss</div>
</div>

<script>
(() => {
  // ==============================================================
  // 1) BAKE YOUR KEY IN HERE
  // ==============================================================
  // Paste your (ROTATED) key here.
  // If you leave it as PASTE_KEY_HERE, the page will not auto-start.
  const BAKED_API_KEY = "PASTE_KEY_HERE";
  const AUTO_START_ON_LOAD = true;

  // Route: SF â†’ NYC (rough Iâ€‘80-ish)
  const WAYPOINTS = [
    {name:"San Francisco, CA", lat:37.7749, lng:-122.4194, state:"CA"},
    {name:"Oakland, CA", lat:37.8044, lng:-122.2711, state:"CA"},
    {name:"Sacramento, CA", lat:38.5816, lng:-121.4944, state:"CA"},
    {name:"Reno, NV", lat:39.5296, lng:-119.8138, state:"NV"},
    {name:"Salt Lake City, UT", lat:40.7608, lng:-111.8910, state:"UT"},
    {name:"Cheyenne, WY", lat:41.1400, lng:-104.8202, state:"WY"},
    {name:"Omaha, NE", lat:41.2565, lng:-95.9345, state:"NE"},
    {name:"Des Moines, IA", lat:41.5868, lng:-93.6250, state:"IA"},
    {name:"Chicago (near), IL", lat:41.8781, lng:-87.6298, state:"IL"},
    {name:"Cleveland, OH", lat:41.4993, lng:-81.6944, state:"OH"},
    {name:"New York, NY", lat:40.7128, lng:-74.0060, state:"NY"}
  ];

  const SPEED_MPH = 50;
  const SPEED_MPS = SPEED_MPH * 1609.344 / 3600;

  // DOM
  const $ = (id) => document.getElementById(id);
  const apiKeyEl = $("apiKey");
  const startBtn = $("startBtn");
  const pauseBtn = $("pauseBtn");
  const resetBtn = $("resetBtn");
  const offlineToggle = $("offlineToggle");
  const statusEl = $("status");
  const progressPctEl = $("progressPct");
  const milesEl = $("miles");
  const nowLocEl = $("nowLoc");
  const nextLocEl = $("nextLoc");
  const wxEl = $("wx");
  const logEl = $("log");
  const overlay = $("overlay");

  // Weather canvas
  const canvas = $("weatherCanvas");
  const ctx = canvas.getContext("2d");
  const particles = [];
  let wxMode = "none";
  let wxIntensity = 0;

  function resizeCanvas(){
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  // Persistent state
  const STORE_KEY = "sv_trip_baked";
  function loadState(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY) || "null"); } catch{ return null; } }
  function saveState(){ localStorage.setItem(STORE_KEY, JSON.stringify(state)); }

  let state = loadState() || {
    running:false,
    offlineContinue:false,
    wpIndex:0,
    t:0,
    meters:0,
    lastSeenAt:Date.now(),
    lastMilestoneIndex:0,
    lastState:WAYPOINTS[0].state,
    apiKey:"",
    log:[]
  };

  // Bake the key into the input & state
  if (BAKED_API_KEY && BAKED_API_KEY !== "PASTE_KEY_HERE"){
    apiKeyEl.value = BAKED_API_KEY;
    state.apiKey = BAKED_API_KEY;
  } else {
    // Keep whatever is in localStorage (if any)
    apiKeyEl.value = state.apiKey || "";
  }
  offlineToggle.checked = !!state.offlineContinue;

  function pushLog(text){
    const ts = new Date().toLocaleString();
    state.log.unshift({ts, text});
    state.log = state.log.slice(0, 200);
    renderLog();
    saveState();
  }
  function renderLog(){
    logEl.innerHTML = state.log.map((it) => `<div class="item"><b>${it.ts}</b><br>${it.text}</div>`).join("") ||
      `<div class="item" style="opacity:.8">Logbook emptyâ€¦ (yet)</div>`;
  }
  renderLog();

  // Distance math
  function haversine(a,b){
    const R=6371000;
    const toRad=(d)=>d*Math.PI/180;
    const dLat=toRad(b.lat-a.lat);
    const dLon=toRad(b.lng-a.lng);
    const lat1=toRad(a.lat), lat2=toRad(b.lat);
    const s=Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.min(1, Math.sqrt(s)));
  }
  function lerp(a,b,t){ return a+(b-a)*t; }
  function posOnSeg(seg,t){ return {lat: lerp(seg.a.lat,seg.b.lat,t), lng: lerp(seg.a.lng,seg.b.lng,t)}; }
  function headingDeg(from,to){
    const toRad=(d)=>d*Math.PI/180;
    const toDeg=(r)=>r*180/Math.PI;
    const Ï†1=toRad(from.lat), Ï†2=toRad(to.lat);
    const Î»1=toRad(from.lng), Î»2=toRad(to.lng);
    const y=Math.sin(Î»2-Î»1)*Math.cos(Ï†2);
    const x=Math.cos(Ï†1)*Math.sin(Ï†2)-Math.sin(Ï†1)*Math.cos(Ï†2)*Math.cos(Î»2-Î»1);
    return (toDeg(Math.atan2(y,x))+360)%360;
  }

  // Segments
  const segments=[];
  let totalMeters=0;
  for(let i=0;i<WAYPOINTS.length-1;i++){
    const a=WAYPOINTS[i], b=WAYPOINTS[i+1];
    const m=haversine(a,b);
    segments.push({a,b,m});
    totalMeters += m;
  }
  function miles(m){ return Math.round(m/1609.344); }
  function pct(){ return (state.meters/totalMeters)*100; }

  // Progress simulation
  function advance(dt){
    let remaining = SPEED_MPS * dt;
    while (remaining > 0 && state.wpIndex < segments.length){
      const seg = segments[state.wpIndex];
      const segRemaining = seg.m * (1 - state.t);
      const step = Math.min(segRemaining, remaining);
      const frac = step / seg.m;
      state.t += frac;
      state.meters += step;
      remaining -= step;
      if (state.t >= 1){
        state.wpIndex++;
        state.t = 0;
        if (state.wpIndex < segments.length){
          const entered = segments[state.wpIndex].a;
          if (entered.state !== state.lastState){
            pushLog(`Crossed into ${entered.state}.`);
            state.lastState = entered.state;
          }
          pushLog(`Passed ${entered.name}.`);
        } else {
          pushLog("Arrived in New York City! ðŸ—½");
          state.running = false;
        }
      }
    }
    saveState();
  }

  // Offline catch-up
  function handleReturn(){
    const now = Date.now();
    if (state.offlineContinue && state.lastSeenAt){
      const elapsed = (now - state.lastSeenAt) / 1000;
      if (elapsed > 5 && !state.running){
        const driven = miles(SPEED_MPS * elapsed);
        pushLog(`Welcome back â€” you drove ~${driven} miles while away.`);
        advance(elapsed);
      }
    }
    state.lastSeenAt = now;
    saveState();
  }

  // Google Maps loader + Street View
  let googleReady = false;
  let pano = null;
  let svService = null;

  function showOverlay(msg){
    overlay.textContent = msg;
    overlay.classList.remove("hidden");
  }
  function hideOverlay(){
    overlay.classList.add("hidden");
  }
  overlay.addEventListener("click", hideOverlay);

  function loadGoogle(key){
    return new Promise((resolve, reject) => {
      if (googleReady) return resolve();
      if (!key) return reject(new Error("Missing API key."));

      // Called by Google Maps if auth fails
      window.gm_authFailure = () => reject(new Error(
        "Google Maps auth failure. Check: (1) referrer restriction includes your GitHub Pages URL, and (2) Maps JavaScript API is enabled."
      ));

      const s = document.createElement("script");
      s.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(key)}&v=weekly`;
      s.async = true;
      s.onerror = () => reject(new Error("Failed to load Maps JS script."));
      s.onload = () => { googleReady = true; resolve(); };
      document.head.appendChild(s);
    });
  }

  async function ensureStreetView(){
    const key = apiKeyEl.value.trim();
    state.apiKey = key; saveState();
    await loadGoogle(key);

    if (!pano){
      pano = new google.maps.StreetViewPanorama(document.getElementById("pano"), {
        addressControl:false, linksControl:false, panControl:true,
        motionTracking:false, motionTrackingControl:false,
        fullscreenControl:true, zoomControl:true, showRoadLabels:false,
      });
      svService = new google.maps.StreetViewService();
    }
  }

  // Weather via Open-Meteo (no key)
  async function fetchWeather(lat,lng){
    const url = new URL("https://api.open-meteo.com/v1/forecast");
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lng);
    url.searchParams.set("current", "temperature_2m,precipitation,rain,snowfall,weather_code");
    url.searchParams.set("timezone", "auto");
    const res = await fetch(url.toString());
    if(!res.ok) throw new Error("Weather fetch failed");
    return res.json();
  }
  function interpretWeather(current){
    const t = current?.temperature_2m;
    const precip = current?.precipitation ?? 0;
    const rain = current?.rain ?? 0;
    const snow = current?.snowfall ?? 0;
    let mode = "none";
    if (snow > 0) mode = "snow";
    else if (rain > 0 || precip > 0) mode = "rain";
    const intensity = Math.max(0, Math.min(1, (precip) / 4));
    return {t, precip, rain, snow, mode, intensity, code: current?.weather_code};
  }
  function spawnParticles(){
    const count = wxMode === "rain" ? Math.floor(150 + wxIntensity*300) :
                  wxMode === "snow" ? Math.floor(80 + wxIntensity*200) : 0;
    while (particles.length < count){
      particles.push({
        x: Math.random()*window.innerWidth,
        y: Math.random()*window.innerHeight,
        vx: wxMode==="rain" ? -50 : (-10 + Math.random()*20),
        vy: wxMode==="rain" ? (380 + Math.random()*240) : (60 + Math.random()*80),
        s: wxMode==="rain" ? (10 + Math.random()*18) : (2 + Math.random()*4),
        a: 0.35 + Math.random()*0.35
      });
    }
    while (particles.length > count) particles.pop();
  }
  function drawWeather(dt){
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
    if (wxMode === "none" || wxIntensity <= 0.02) return;

    const g = ctx.createLinearGradient(0,0,0,window.innerHeight);
    g.addColorStop(0, `rgba(255,255,255,${0.02*wxIntensity})`);
    g.addColorStop(1, `rgba(255,255,255,0)`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

    ctx.save();
    if (wxMode === "rain"){
      ctx.strokeStyle = "rgba(200,230,255,0.7)";
      ctx.lineWidth = 1;
      for (const p of particles){
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.y > window.innerHeight+40 || p.x < -40){
          p.x = window.innerWidth + Math.random()*120;
          p.y = -Math.random()*200;
        }
        ctx.globalAlpha = p.a * (0.4 + 0.6*wxIntensity);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x - p.s*0.35, p.y - p.s);
        ctx.stroke();
      }
    } else if (wxMode === "snow"){
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      for (const p of particles){
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.y > window.innerHeight+10 || p.x < -10 || p.x > window.innerWidth+10){
          p.x = Math.random()*window.innerWidth;
          p.y = -Math.random()*120;
        }
        ctx.globalAlpha = p.a * (0.4 + 0.6*wxIntensity);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.s, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.restore();
  }

  // Scene updates
  let lastSVUpdate = 0;
  let lastWxUpdate = 0;
  async function updateScene(nowMs){
    progressPctEl.textContent = pct().toFixed(1) + "%";
    milesEl.textContent = miles(state.meters).toString();

    if (state.wpIndex >= segments.length){
      nowLocEl.textContent = WAYPOINTS[WAYPOINTS.length-1].name;
      nextLocEl.textContent = "â€”";
      statusEl.textContent = "Arrived in NYC!";
      return;
    }

    const seg = segments[state.wpIndex];
    const p = posOnSeg(seg, Math.max(0, Math.min(1, state.t)));
    nowLocEl.textContent = seg.a.name;
    nextLocEl.textContent = seg.b.name;

    if (nowMs - lastSVUpdate > 2500){
      lastSVUpdate = nowMs;
      try{
        await ensureStreetView();
        const lookAhead = posOnSeg(seg, Math.min(1, state.t + 0.02));
        const hdg = headingDeg(p, lookAhead);
        const panoData = await new Promise((resolve, reject) => {
          svService.getPanorama({ location: p, radius: 80, source: google.maps.StreetViewSource.OUTDOOR }, (data, status) => {
            if (status === "OK" && data) resolve(data);
            else reject(new Error("No Street View here (coverage gap)."));
          });
        });
        pano.setPano(panoData.location.pano);
        pano.setPov({ heading: hdg, pitch: 0 });
        statusEl.textContent = `Drivingâ€¦ ${miles(state.meters)} / ${miles(totalMeters)} mi`;
      } catch(e){
        // If auth fails, STOP skipping and tell the user.
        if (String(e.message || "").toLowerCase().includes("auth")){
          state.running = false;
          saveState();
          statusEl.textContent = "Stopped (API key problem).";
          showOverlay("Google Maps denied the request. Fix your key restrictions, then reload.");
          return;
        }
        // Otherwise coverage gap: nudge forward
        statusEl.textContent = "Street View gapâ€¦ skipping forward";
        advance(20);
      }
    }

    if (nowMs - lastWxUpdate > 30000){
      lastWxUpdate = nowMs;
      try{
        const wx = await fetchWeather(p.lat, p.lng);
        const iw = interpretWeather(wx.current);
        const label = `${Math.round(iw.t)}Â°C â€¢ precip ${iw.precip ?? 0}`;
        wxEl.textContent = (iw.mode==="none") ? `${label} â€¢ clear` : `${label} â€¢ ${iw.mode}`;
        const prev = wxMode;
        wxMode = iw.mode;
        wxIntensity = iw.intensity;
        spawnParticles();
        if (wxMode !== prev && wxMode !== "none"){
          pushLog(`Weather: ${wxMode} (intensity ${(wxIntensity*100).toFixed(0)}%).`);
        }
      } catch {
        wxEl.textContent = "Weather unavailable";
      }
    }
  }

  let lastFrame = performance.now();
  async function frame(now){
    const dt = Math.min(0.25, (now - lastFrame) / 1000);
    lastFrame = now;
    if (state.running) advance(dt);
    drawWeather(dt);
    await updateScene(now);
    requestAnimationFrame(frame);
  }

  // UI events
  startBtn.addEventListener("click", async () => {
    state.apiKey = apiKeyEl.value.trim();
    state.running = true;
    state.offlineContinue = offlineToggle.checked;
    saveState();
    try{
      statusEl.textContent = "Startingâ€¦";
      await ensureStreetView();
      hideOverlay();
      pushLog("Started trip.");
    } catch(e){
      state.running = false;
      saveState();
      statusEl.textContent = "Error.";
      showOverlay(`Error: ${e.message}`);
    }
  });
  pauseBtn.addEventListener("click", () => {
    state.running = false;
    saveState();
    pushLog("Paused.");
    statusEl.textContent = "Paused.";
  });
  resetBtn.addEventListener("click", () => {
    localStorage.removeItem(STORE_KEY);
    state = {
      running:false,
      offlineContinue:offlineToggle.checked,
      wpIndex:0,
      t:0,
      meters:0,
      lastSeenAt:Date.now(),
      lastMilestoneIndex:0,
      lastState:WAYPOINTS[0].state,
      apiKey: apiKeyEl.value.trim(),
      log:[]
    };
    wxMode="none"; wxIntensity=0; particles.length=0;
    renderLog();
    saveState();
    statusEl.textContent = "Reset.";
    wxEl.textContent = "â€”";
    nowLocEl.textContent = WAYPOINTS[0].name;
    nextLocEl.textContent = WAYPOINTS[1].name;
    pushLog("Reset trip.");
  });
  offlineToggle.addEventListener("change", () => {
    state.offlineContinue = offlineToggle.checked;
    saveState();
    pushLog(state.offlineContinue ? "Offline progress enabled." : "Offline progress disabled.");
  });
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) handleReturn();
    state.lastSeenAt = Date.now();
    saveState();
  });
  window.addEventListener("beforeunload", () => {
    state.lastSeenAt = Date.now();
    saveState();
  });

  // Init
  handleReturn();
  statusEl.textContent = "Ready.";
  nowLocEl.textContent = WAYPOINTS[0].name;
  nextLocEl.textContent = WAYPOINTS[1].name;
  requestAnimationFrame(frame);

  // Auto-start if baked key is set
  if (AUTO_START_ON_LOAD && apiKeyEl.value.trim() && apiKeyEl.value.trim() !== "PASTE_KEY_HERE"){
    // Defer one tick so event listeners are attached & UI paints
    setTimeout(() => startBtn.click(), 0);
  } else {
    showOverlay("Paste your Google Maps API key into BAKED_API_KEY (in the file), then reload.");
  }
})();
</script>
</body>
</html>
